Q.1) Read the current directory and display the name of the files, no of files in current directory 
[10 Marks ] 

#include <stdio.h> 
#include <dirent.h> 
 
int main() { 
    DIR *dir; 
    struct dirent *entry; 
    int file_count = 0; 
 
    dir = opendir("."); 
    if (dir == NULL) { 
        perror("opendir"); 
        return 1; 
    } 
 
    printf("Files in the current directory:\n"); 
    while ((entry = readdir(dir)) != NULL) { 
        printf("%s\n", entry->d_name); 
        file_count++; 
    } 
 
    closedir(dir); 
    printf("Total number of files: %d\n", file_count); 
    return 0; 
} 
 
Q.2) Write a C program to implement the following unix/linux command (use fork, pipe and exec 
system call). Your program should block the signal Ctrl-C and Ctrl-\ signal during the execution. i. 
Ls –l | wc –l [20 Marks ] 

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <signal.h> 
#include <sys/wait.h> 
 
void block_signals() { 
    sigset_t set; 
    sigemptyset(&set); 
    sigaddset(&set, SIGINT);  // Block Ctrl-C 
    sigaddset(&set, SIGQUIT); // Block Ctrl-\ 
    sigprocmask(SIG_BLOCK, &set, NULL); 
} 
 
int main() { 
    int pipe_fd[2]; 
    pid_t pid1, pid2; 
 
    pipe(pipe_fd); 
 
    pid1 = fork(); 
    if (pid1 == 0) { // First child: executes 'ls -l' 
        close(pipe_fd[0]); // Close read end 
        dup2(pipe_fd[1], STDOUT_FILENO); // Redirect stdout to the pipe 
        execlp("ls", "ls", "-l", NULL); 
        perror("execlp ls failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    pid2 = fork(); 
    if (pid2 == 0) { // Second child: executes 'wc -l' 
        close(pipe_fd[1]); // Close write end 
dup2(pipe_fd[0], STDIN_FILENO); // Redirect stdin from the pipe 
execlp("wc", "wc", "-l", NULL); 
perror("execlp wc failed"); 
exit(EXIT_FAILURE); 
} 
// Parent process 
block_signals(); // Block Ctrl-C and Ctrl-\ signals 
close(pipe_fd[0]); 
close(pipe_fd[1]); 
wait(NULL); // Wait for both children to finish 
wait(NULL); 
return 0; 
} 
