Q.1) Print the type of file and inode number where file name accepted through Command Line [10 
Marks ] 

#include <stdio.h> 
#include <sys/stat.h> 
 
int main(int argc, char *argv[]) { 
    struct stat file_stat; 
    for (int i = 1; i < argc; i++) { 
        if (stat(argv[i], &file_stat) == -1) { 
            perror("stat"); 
            continue; 
        } 
        printf("File: %s, Inode: %ld, ", argv[i], file_stat.st_ino); 
        if (S_ISREG(file_stat.st_mode)) printf("Regular file\n"); 
        else if (S_ISDIR(file_stat.st_mode)) printf("Directory\n"); 
        else if (S_ISCHR(file_stat.st_mode)) printf("Character device\n"); 
        else if (S_ISBLK(file_stat.st_mode)) printf("Block device\n"); 
        else if (S_ISFIFO(file_stat.st_mode)) printf("FIFO\n"); 
        else if (S_ISLNK(file_stat.st_mode)) printf("Symbolic link\n"); 
        else if (S_ISSOCK(file_stat.st_mode)) printf("Socket\n"); 
        else printf("Unknown file type\n"); 
    } 
    return 0; 
} 

Q.2) Write a C program which creates a child process to run linux/ unix command or any user 
defined program. The parent process set the signal handler for death of child signal and Alarm 
signal. If a child process does not complete its execution in 5 second then parent process kills 
child process. [20 Marks ] 

#include <stdio.h> 
#include <unistd.h> 
#include <signal.h> 
#include <stdlib.h> 
#include <sys/wait.h> 
 
pid_t child_pid; 
 
void handle_alarm(int sig) { 
    printf("Child did not finish in 5 seconds, killing child\n"); 
    kill(child_pid, SIGKILL); 
} 
 
void handle_child_death(int sig) { 
    int status; 
    waitpid(child_pid, &status, 0); 
    if (WIFEXITED(status)) 
        printf("Child finished normally with status %d\n", WEXITSTATUS(status)); 
    else if (WIFSIGNALED(status)) 
        printf("Child killed by signal %d\n", WTERMSIG(status)); 
} 
 
int main() { 
    signal(SIGALRM, handle_alarm); 
    signal(SIGCHLD, handle_child_death); 
 
    child_pid = fork(); 
    if (child_pid == 0) { 
        execlp("sleep", "sleep", "10", NULL); // Simulate long task 
        exit(0); 
    } else { 
        alarm(5); 
        pause(); 
    } 
    return 0; 
} 
