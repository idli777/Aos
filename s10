Q.1) Write a program that illustrates how to execute two commands concurrently with a pipe. [10 
Marks ] 

#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include <sys/wait.h> 
 
int main() { 
    int pipefd[2]; 
    pid_t pid1, pid2; 
 
    if (pipe(pipefd) == -1) { 
        perror("pipe"); 
        return 1; 
    } 
 
    pid1 = fork(); 
    if (pid1 == -1) { 
        perror("fork"); 
        return 1; 
    } 
 
    if (pid1 == 0) { 
        close(pipefd[0]); 
        dup2(pipefd[1], STDOUT_FILENO); 
        execlp("ls", "ls", NULL); 
        perror("execlp ls failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    pid2 = fork(); 
    if (pid2 == -1) { 
        perror("fork"); 
        return 1; 
    } 
 
    if (pid2 == 0) { 
        close(pipefd[1]); 
        dup2(pipefd[0], STDIN_FILENO); 
        execlp("wc", "wc", NULL); 
        perror("execlp wc failed"); 
        exit(EXIT_FAILURE); 
    } 
 
    close(pipefd[0]); 
    close(pipefd[1]); 
    wait(NULL); 
    wait(NULL); 
 
    return 0; 
} 
 
Q.2) Generate parent process to write unnamed pipe and will write into it. Also generate child 
process which will read from pipe [20 Marks ] 

#include <stdio.h> 
#include <unistd.h> 
#include <string.h> 
 
int main() { 
    int fd[2]; 
    pid_t pid; 
    char buffer[100]; 
 
    pipe(fd); 
    pid = fork(); 
 
    if (pid == 0) { 
        close(fd[0]); 
        char *messages[] = {"Hello World", "Hello SPPU", "Linux is Funny"}; 
        for (int i = 0; i < 3; i++) { 
            write(fd[1], messages[i], strlen(messages[i]) + 1); 
            sleep(1); 
        } 
        close(fd[1]); 
    } else { 
        close(fd[1]); 
        while (read(fd[0], buffer, sizeof(buffer)) > 0) { 
            printf("Parent received: %s\n", buffer); 
        } 
        close(fd[0]); 
        wait(NULL); 
    } 
 
    return 0; 
} 
